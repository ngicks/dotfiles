# Neovim LSP Gateway - Implementation Plan

## Goal

Expose Neovim LSP to Claude Code via skills, using a **persistent headless Neovim server** as an LSP gateway.

## Architecture

```
Claude Code
    │
    │ Skill invocation
    ↓
Shell Scripts (lsp-query.sh)
    │
    │ 1. Ensure server running (liveness check)
    │ 2. Connect via RPC socket
    ↓
Neovim Server (nvim --headless -u ~/.config/nvim/init.lua --listen /tmp/nvim-lsp.$USER.sock)
    │
    │ vim.lsp.buf_request_sync() with timeout
    ↓
Language Server (gopls, ts_ls, etc.)
    │
    │ JSON response via RPC
    ↓
Client Neovim (nvim --headless -l rpc_query.lua) → stdout → Claude Code
```

**Key benefit:** Server stays running with LSP attached. First query may be slow (LSP startup), but subsequent queries are fast.

## Design Principles (from Codex review)

1. **No window operations** - Use buffer-only APIs (`bufadd`, `bufload`, no `split`)
2. **Explicit timeouts** - All LSP calls have timeouts, return `{ok:false, error:"timeout"}` on failure
3. **Liveness checks** - Validate socket+PID before connecting, clean stale files
4. **Fire autocmds for LSP attachment** - Explicitly trigger `BufReadPost`, `FileType` after `bufload`
5. **Wait-for-client loop** - Poll `vim.lsp.get_clients({bufnr})` before making LSP requests
6. **Normalize responses** - Convert LSP objects to plain tables before JSON encoding
7. **Per-user socket path** - Use `$USER` in socket path to avoid collisions

## Codex Review Issues Addressed

| Issue                                           | Severity | Resolution                                            |
| ----------------------------------------------- | -------- | ----------------------------------------------------- |
| LSP attach may not trigger with buffer-only ops | High     | Fire `BufReadPost` and `FileType` autocmds explicitly |
| RPC query invocation unclear                    | High     | Clarify: runs via `nvim --headless -l rpc_query.lua`  |
| Root/cwd handling                               | Medium   | LSP uses buffer's directory for root detection        |
| Wait-for-client before request                  | Medium   | Implement `wait_for_client(bufnr, timeout)`           |
| Non-serializable LSP objects                    | Medium   | Normalize to plain `{filename, line, col}` tables     |
| Socket path collision                           | Low      | Use `/tmp/nvim-lsp.$USER.sock`                        |

---

## Files to Create

| Path                                             | Purpose                                  |
| ------------------------------------------------ | ---------------------------------------- |
| `config/nvim/lua/lsp_gateway/init.lua`           | Core LSP query functions (headless-safe) |
| `config/nvim/lua/lsp_gateway/rpc_query.lua`      | RPC client to query server               |
| `.claude/skills/nvim-lsp/SKILL.md`               | Skill definition for Claude Code         |
| `.claude/skills/nvim-lsp/scripts/nvim-server.sh` | Server lifecycle management              |
| `.claude/skills/nvim-lsp/scripts/lsp-query.sh`   | Main query entry point                   |

## Directory Structure

```
config/nvim/lua/
└── lsp_gateway/
    ├── init.lua       # LSP functions (runs on server)
    └── rpc_query.lua  # RPC client (runs locally)

.claude/skills/
└── nvim-lsp/
    ├── SKILL.md
    └── scripts/
        ├── nvim-server.sh
        └── lsp-query.sh
```

---

## Implementation Details

### 1. Server Management Script

**File:** `.claude/skills/nvim-lsp/scripts/nvim-server.sh`

- Manages persistent Neovim LSP server
- **Socket path:** `/tmp/nvim-lsp.$USER.sock` (per-user to avoid collisions)
- **Startup command:** `nvim --headless -u ~/.config/nvim/init.lua --listen $SOCKET`
- Uses RPC health check for liveness (not just PID/socket existence)
- Commands: `start`, `stop`, `restart`, `status`, `socket`
- Auto-cleans stale socket/PID files
- Lockfile to prevent concurrent startup races

### 2. Lua Gateway Module

**File:** `config/nvim/lua/lsp_gateway/init.lua`

Functions:

- `open_file(filepath, timeout_ms)` - Open file, fire autocmds, wait for LSP
- `wait_for_client(bufnr, timeout_ms)` - Poll until LSP client attached
- `get_definition(filepath, line, col)` - textDocument/definition
- `get_references(filepath, line, col)` - textDocument/references
- `get_hover(filepath, line, col)` - textDocument/hover
- `get_document_symbols(filepath)` - textDocument/documentSymbol
- `get_diagnostics(filepath)` - vim.diagnostic.get
- `health()` - Server health check

Key implementation details:

- `open_file()` fires `BufReadPost` and `FileType` autocmds to trigger LSP attachment
- `wait_for_client()` polls `vim.lsp.get_clients({bufnr})` with capped retries
- All responses normalized to plain tables: `{filename, line, col}` for locations
- Uses **0-indexed** line/col positions (matches LSP protocol)
- Returns `{ok: bool, result?: table, error?: string}`
- Uses `vim.lsp.buf_request_sync()` with explicit timeouts
- Build position params without window dependencies

### 3. RPC Query Script

**File:** `config/nvim/lua/lsp_gateway/rpc_query.lua`

**Invocation:** `nvim --headless -l ~/.config/nvim/lua/lsp_gateway/rpc_query.lua <socket> <command> <args...>`

- Runs in a fresh Neovim instance (minimal startup, no UI)
- Connects to running server via `vim.fn.sockconnect('pipe', socket, {rpc = true})`
- Executes Lua on server via `vim.rpcrequest(channel, 'nvim_exec_lua', lua_code, {})`
- Handles and surfaces `nvim_exec_lua` errors
- Outputs JSON to stdout via `io.stdout:write(vim.json.encode(result))`
- Exits cleanly with `vim.cmd('quitall!')`

### 4. Shell Wrapper

**File:** `.claude/skills/nvim-lsp/scripts/lsp-query.sh`

- Ensures server is running before each query
- Converts relative paths to absolute
- Invokes RPC query script

### 5. Skill Definition

**File:** `.claude/skills/nvim-lsp/SKILL.md`

Commands exposed to Claude Code:

```bash
# Definition
!$SKILL_DIR/scripts/lsp-query.sh definition <filepath> <line> <col>

# References
!$SKILL_DIR/scripts/lsp-query.sh references <filepath> <line> <col>

# Hover
!$SKILL_DIR/scripts/lsp-query.sh hover <filepath> <line> <col>

# Symbols
!$SKILL_DIR/scripts/lsp-query.sh symbols <filepath>

# Diagnostics
!$SKILL_DIR/scripts/lsp-query.sh diagnostics <filepath>
```

---

## Performance Characteristics

| Scenario                                     | Latency      |
| -------------------------------------------- | ------------ |
| First query (server cold start + LSP attach) | ~2-5 seconds |
| Same file, subsequent query                  | ~50-200ms    |
| Different file (LSP needs to attach)         | ~500ms-2s    |
| Server already has file loaded               | ~50-100ms    |

**Server lifecycle:**

- Starts on first query
- Stays running indefinitely (until explicit stop or reboot)
- LSP clients remain attached to previously opened files

---

## Verification

```bash
# 1. Start server manually
~/.dotfiles/.claude/skills/nvim-lsp/scripts/nvim-server.sh start

# 2. Check status
~/.dotfiles/.claude/skills/nvim-lsp/scripts/nvim-server.sh status

# 3. Test query
~/.dotfiles/.claude/skills/nvim-lsp/scripts/lsp-query.sh definition /path/to/file.go 10 5

# 4. Verify JSON output
# Should see: {"ok":true,"result":[...]}
```

---

## Output Format

All commands return JSON:

**Success:**

```json
{"ok": true, "result": [...]}
```

**Error:**

```json
{ "ok": false, "error": "No LSP client attached" }
```

### Example Results

**Definition:**

```json
{
  "ok": true,
  "result": [{ "filename": "/path/to/file.go", "line": 5, "col": 0 }]
}
```

**References:**

```json
{
  "ok": true,
  "result": [
    { "filename": "/path/to/file.go", "line": 10, "col": 2 },
    { "filename": "/path/to/other.go", "line": 25, "col": 8 }
  ]
}
```

**Hover:**

```json
{ "ok": true, "result": { "contents": "func main()" } }
```

**Symbols:**

```json
{
  "ok": true,
  "result": [
    { "name": "MyStruct", "kind": "Struct", "line": 5, "col": 0 },
    { "name": "MyStruct.Method", "kind": "Method", "line": 10, "col": 0 }
  ]
}
```

**Diagnostics:**

```json
{
  "ok": true,
  "result": [
    {
      "line": 10,
      "col": 5,
      "severity": "Error",
      "message": "undefined: foo",
      "source": "gopls"
    }
  ]
}
```
