# lsp-gw: Daemon architecture with gRPC

## Context

The current model spawns one neovim per project, each on its own socket. Clients auto-start neovim via `EnsureRunning()`. This leads to: redundant Lua runtime copies per project, lock/race handling for concurrent starts, and socket-per-project management scattered across client code.

The new model: a single Go daemon process listening on one Unix socket via gRPC. The daemon manages neovim processes internally, spawning them lazily on first query for each project root. Clients detect their project root and include it in each gRPC request. The daemon must be explicitly started before queries work.

## Architecture overview

```
Client (lsp-gw definition ...)
  │ gRPC over Unix socket
  ▼
Daemon (lsp-gw server start)
  │ manages map[projectRoot] → neovim
  │ prepares Lua runtime once
  │ per-project mutex for serialized neovim access
  ▼
Neovim (headless, per project root)
  │ msgpack RPC (existing gateway.Connect / QueryGateway)
  ▼
gopls / LSP server
```

## Concurrency model (from codex review)

The `*nvim.Nvim` go-client is **not safe for concurrent use**. gRPC handlers run concurrently. We need:

1. **Per-project mutex** in `projectState` — lock around every `ExecLua` call to serialize access to the shared neovim client.
2. **`singleflight.Group`** keyed by project root in `ensureNeovim` — prevents duplicate neovim starts when concurrent requests arrive for the same uninitialized project. The global `Daemon.mu` is only held briefly to read/write the projects map, never during the spawn.
3. **Stale client recovery** — on any `ExecLua` error, close the client, remove the project entry, and retry once by spawning a new neovim. This handles neovim crashes and Lua idle self-shutdown.

## Response unwrapping

Lua returns `{ok, error, result}` maps. The daemon must **unwrap** these into the gRPC `QueryResponse` fields (not nest the whole Lua map inside `result`). This keeps CLI JSON output identical to the current format.

## Files to create

### 1. `proto/lspgw.proto`

```protobuf
syntax = "proto3";
package lspgw;
option go_package = "github.com/watage/lsp-gw/proto";

import "google/protobuf/struct.proto";

service LspGateway {
  rpc GetDefinition(LocationRequest) returns (QueryResponse);
  rpc GetReferences(LocationRequest) returns (QueryResponse);
  rpc GetHover(LocationRequest) returns (QueryResponse);
  rpc GetDocumentSymbols(FileRequest) returns (QueryResponse);
  rpc GetDiagnostics(FileRequest) returns (QueryResponse);
  rpc Health(ProjectRequest) returns (QueryResponse);
  rpc DaemonStatus(DaemonStatusRequest) returns (QueryResponse);
  rpc Shutdown(ShutdownRequest) returns (QueryResponse);
}

message LocationRequest {
  string project = 1;
  string filepath = 2;
  int32 line = 3;   // 0-based (LSP convention)
  int32 col = 4;    // 0-based (LSP convention)
}

message FileRequest {
  string project = 1;
  string filepath = 2;
}

message ProjectRequest {
  string project = 1;
}

message DaemonStatusRequest {}

message ShutdownRequest {}

message QueryResponse {
  bool ok = 1;
  string error = 2;
  google.protobuf.Value result = 3;
}
```

### 2. `proto/generate.go` — `go:generate` directive

```go
package proto

//go:generate protoc --go_out=.. --go-grpc_out=.. proto/lspgw.proto
```

Run with `go generate ./...` from the module root.

### 3. `proto/lspgw.pb.go` + `proto/lspgw_grpc.pb.go` (generated, checked in)

### 4. `server/daemon.go` — gRPC server + neovim pool

```go
type Daemon struct {
    proto.UnimplementedLspGatewayServer
    socket       string
    luaDir       string
    maxIdleMins  int
    mu           sync.Mutex                // protects projects map
    projects     map[string]*projectState  // projectRoot → state
    sf           singleflight.Group        // dedup concurrent ensureNeovim
    grpcServer   *grpc.Server
    listener     net.Listener
}

type projectState struct {
    mu         sync.Mutex   // serializes ExecLua calls to this neovim
    nvimSocket string
    client     *nvim.Nvim
}
```

Key methods:
- `NewDaemon(socket string, maxIdleMins int) *Daemon`
- `(d *Daemon) Run(ctx context.Context) error` — prepare lua once, listen, serve, block until ctx cancelled
- `(d *Daemon) Shutdown()` — stop all neovims, cleanup lua, graceful grpc stop
- `(d *Daemon) ensureNeovim(projectRoot string) (*projectState, error)` — uses `d.sf.Do(projectRoot, ...)` to dedup
- `(d *Daemon) queryNeovim(projectRoot, luaCode string, args ...any) (map[string]any, error)` — locks `ps.mu`, calls ExecLua, on error retries once after respawn
- Each gRPC method: extract project from request → `queryNeovim()` → unwrap Lua `{ok,error,result}` → map to `QueryResponse` fields

`ensureNeovim` logic (via singleflight):
1. `d.sf.Do(projectRoot, func() ...)`:
   a. Lock `d.mu`, check `d.projects[projectRoot]` — if exists, unlock and return it
   b. Unlock `d.mu`
   c. Generate nvim socket: `filepath.Join(SocketDir(), hash(projectRoot)+".nvim.sock")`
   d. Call `StartNeovim(nvimSocket, projectRoot, d.luaDir, d.maxIdleMins)`
   e. Connect via `gateway.Connect(nvimSocket)`
   f. Lock `d.mu`, store in map, unlock, return

`queryNeovim` logic (retry-on-error):
1. `ps := ensureNeovim(projectRoot)`
2. `ps.mu.Lock()` → `gateway.QueryGateway(ps.client, luaCode, args...)` → `ps.mu.Unlock()`
3. If error: `d.removeProject(projectRoot)` → `StopNeovim(ps.nvimSocket)` → retry step 1 once

### 5. `integration_test.go` — updated for daemon model

`TestMain`:
1. Create temp Go project
2. Start daemon in background goroutine via `daemon.Run(ctx)`
3. Wait for daemon socket to be ready
4. Run tests (gRPC client queries with project root set to temp dir)
5. Cancel context, daemon shuts down

Each test: create gRPC client → call RPC with `project: testProjectDir` → assert response.

## Files to modify

### 5. `server/server.go`

**Remove**: `ProjectSocket()`, `EnsureRunning()`, `acquireLock()`, `releaseLock()`, `lockfilePath()`, `sidecarPath()`, `cleanupSidecar()`, `ServerStatus()` (moved to daemon), the double-check in StartServer, sidecar file management.

**Simplify `StartServer`** → rename to `StartNeovim(nvimSocket, projectRoot, luaDir string, maxIdleMins int) error`:
- No lock acquisition (singleflight prevents concurrent starts)
- No `PrepareLuaRuntime` call (daemon did it once)
- Accept `luaDir` as parameter instead of calling `PrepareLuaRuntime()`
- No sidecar file (daemon tracks lua dir)
- Keep: socket dir mkdir, stale socket removal, nvim spawn, readiness poll

**Simplify `StopServer`** → rename to `StopNeovim(nvimSocket string) error`:
- No lock/sidecar cleanup
- Just connect, send `qa!`, wait, remove socket file

**Keep**: `SocketDir()`, `DaemonSocket()` (new: returns fixed path `SocketDir()/daemon.sock`), `DetectProjectRoot()`, `IsServerRunning()`.

### 6. `server/lua.go`

No changes. `PrepareLuaRuntime()` / `CleanupLuaRuntime()` called once by daemon.

### 7. `gateway/gateway.go`

No changes. Still used by daemon to talk to neovim processes.

### 8. `cmd/root.go`

- Keep `--project` and `--socket` as persistent flags
- `--max-idle` → move to `server start` only (local flag)
- `resolveSocketAndProject()` → split into `resolveDaemonSocket()` and `resolveProject()`
- `resolveDaemonSocket()`: `--socket` flag → `LSP_GW_SOCKET` env → `server.DaemonSocket()`
- `resolveProject()`: `--project` flag → `server.DetectProjectRoot()`
- `runQuery()` → removed (each command calls gRPC directly)
- Add `dialDaemon(socket string) (*grpc.ClientConn, proto.LspGatewayClient, error)`
- Add `outputQueryResponse(resp *proto.QueryResponse, err error)` — converts to JSON and prints

### 9. `cmd/server.go`

- `server start [--max-idle N]`: create `Daemon`, call `daemon.Run(cmd.Context())` (foreground, blocks)
- `server stop`: gRPC client → call `Shutdown` RPC
- `server status`: gRPC client → call `DaemonStatus` RPC

### 10. Query command files (`cmd/definition.go`, etc.)

Change from direct neovim connection to gRPC:
```go
socket := resolveDaemonSocket()
project := resolveProject()
conn, client := dialDaemon(socket)
defer conn.Close()
resp, err := client.GetDefinition(ctx, &proto.LocationRequest{
    Project: project, Filepath: filepath, Line: int32(line), Col: int32(col),
})
outputQueryResponse(resp, err)
```

### 11. `go.mod`

Add:
- `google.golang.org/grpc`
- `google.golang.org/protobuf`

### 12. Lua idle cleanup (`server/lua/lsp_gateway/init.lua`)

Simplify `cleanup_runtime_files()`: only remove the neovim's own socket (`g:lsp_gw_socket`). Remove sidecar and lockfile cleanup — daemon handles those. The daemon detects the dead connection on next query and respawns.

## Detailed change summary

| File | Action | Key changes |
|------|--------|-------------|
| `proto/lspgw.proto` | Create | gRPC service definition with 8 RPCs |
| `proto/*.pb.go` | Generate | protoc output, checked in |
| `server/daemon.go` | Create | Daemon struct, gRPC server, neovim pool, singleflight, per-project mutex, retry |
| `server/server.go` | Modify | Simplify to StartNeovim/StopNeovim, add DaemonSocket(), remove locks/sidecars/EnsureRunning |
| `server/lua.go` | Keep | No changes |
| `server/lua/lsp_gateway/init.lua` | Modify | Simplify cleanup to only remove own nvim socket |
| `gateway/gateway.go` | Keep | No changes |
| `cmd/root.go` | Modify | Split resolve functions, add gRPC client helpers |
| `cmd/server.go` | Modify | start=foreground daemon, stop=gRPC shutdown, status=gRPC status |
| `cmd/definition.go` | Modify | Use gRPC client |
| `cmd/references.go` | Modify | Use gRPC client |
| `cmd/hover.go` | Modify | Use gRPC client |
| `cmd/symbols.go` | Modify | Use gRPC client |
| `cmd/diagnostics.go` | Modify | Use gRPC client |
| `cmd/health.go` | Modify | Use gRPC client |
| `cmd/cmd_test.go` | Modify | Update for changed flags |
| `server/server_test.go` | Modify | Update for renamed functions, remove lock/sidecar tests |
| `go.mod` | Modify | Add grpc + protobuf deps |
| `integration_test.go` | Rewrite | Use daemon + gRPC |

## Verification

```bash
# Generate proto (from module root)
cd tools/lsp-gw && go generate ./...

# Unit tests (no server needed)
go test ./...

# Integration tests
go test -tags integration -timeout 120s -v -run TestIntegration
```
